## The Twelve-Factor Application

Factors that I ran into that initially did not make much sense to me was the Dev/Prod parity. 
After my first read over the chapters, I could not figure out what the goals for it was.  
A second and third read showed that Dev/Prod parity is more of attempting
to keep your services as similar as possible in order to not have to keep track of so many
things.  One thing I really agree with is including config files in the project.  Without
any config files, it makes it very tedious to go in and change trivial things such as unit
conversions, etc.  I think the Twelve-Factor app fits into our project because we will utilize
many of the steps provided.  Just to name a few, the codebase step will fit in, the log step will
fit in, and the dependencies will fit in.


## Chapter 7 :The Pragmatic Programmer

This chapter provided some valuable and helpful information regarding the beginning of the project phase.  You must go beyond the user requirement list and dig into what they mean more deeply.  While solving "impossible" puzzles, it is interesting that they aren't always as hard as they appear to be.  Jumping into coding is a big mistake because you are prone to lots of errors and refactoring since you most likely do not have a good grasp on what they want yet.  I think it is a good idea to be as specific as possible as well, to avoid any unnecessary errors due to confusion over doubt and details.



## Chapter 2 :The Pragmatic Programmer

I agree with the part in this Chapter, specifically the ending, about giving rough estimates and even saying you will get back at a later date.  I agree with this because if you have a rough idea of how long something will take you, it is always good to give a timeline.  It is not always possible to know how long something will take though,so getting back at a later date is sometimes best.  I found the section titled Domain Languages to be the most confusing, as it is a little vague in the description.  I found the Tracer bullet section to be most interesting, because you can give the consumer a rough idea of what is going to happen without fully doing it yet.


## Chapter 1 : The Pragmatic Programmer

In the first chapter of The Pragmatic Programmer, I agree with The Cat Ate My Source Code, which essentially is saying to take responsibility and do not blame someone or something else.    Something that confused me in this chapter was the part about stone soup and boiled frogs, more specifically the part about the boiled frogs.  I get that the analogy is saying that you should focus on the bigger picture, but I feel eventually you have to delve into the details.  The Knowledge Portfolio is an interesting approach of which I've never heard to keep your learning / knowledge up to date, and I do believe it is useful to keep in the back of your mind. 


## Why I am taking Software Engineering

I am taking software engineering in order to broaden my knowledge in the Computer Science field.  Something about software engineering I enjoy is that it is a hands-on and project based class, because most CS classes in college are theory based, and involve less hands-on opportunities.  Getting experience with projects is important because the reality is most careers in CS are software engineering and technical based, unless you go into academia which is where the theory side is more important.  I have no desire to go to grad-school or into a field of academia/research, so software engineering is vital to take.



## What Software Engineering Means to Me

To me, software engineering has a few different levels to it when I think of it.  The first level is the problem / demand level, meaning
someone encounters an everyday problem they need fixed or a business has a demand for a certain type of software.  Moving on to the next
level, I believe there is a brainstorming phase in which different solutions / approaches are came up with in order to solve said problem.
The first solution is generally not the most efficient solution in regards to time- and space-complexity, so the succeeding levels of 
software engineering is maximizing the efficiency of the algorithms / data structures implemented.  Once there is an acceptably efficient
solution presented, the final level of software engineering is to implement your solution via the gateway of coding, and from there 
debugging any problems / logical errors present.  While I don't believe the solution has to be the most efficient, it should be efficient
for large datasets.


