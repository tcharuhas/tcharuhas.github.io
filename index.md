## Chapter 1 : The Pragmatic Programmer

In the first chapter of The Pragmatic Programmer, I agree with The Cat Ate My Source Code, which essentially is saying to take responsibility and do not blame someone or something else.    Something that confused me in this chapter was the part about stone soup and boiled frogs, more specifically the part about the boiled frogs.  I get that the analogy is saying that you should focus on the bigger picture, but I feel eventually you have to delve into the details.  The Knowledge Portfolio is an interesting approach of which I've never heard to keep your learning / knowledge up to date, and I do believe it is useful to keep in the back of your mind. 


## Why I am taking Software Engineering

I am taking software engineering in order to broaden my knowledge in the Computer Science field.  Something about software engineering I enjoy is that it is a hands-on and project based class, because most CS classes in college are theory based, and involve less hands-on opportunities.  Getting experience with projects is important because the reality is most careers in CS are software engineering and technical based, unless you go into academia which is where the theory side is more important.  I have no desire to go to grad-school or into a field of academia/research, so software engineering is vital to take.



## What Software Engineering Means to Me

To me, software engineering has a few different levels to it when I think of it.  The first level is the problem / demand level, meaning
someone encounters an everyday problem they need fixed or a business has a demand for a certain type of software.  Moving on to the next
level, I believe there is a brainstorming phase in which different solutions / approaches are came up with in order to solve said problem.
The first solution is generally not the most efficient solution in regards to time- and space-complexity, so the succeeding levels of 
software engineering is maximizing the efficiency of the algorithms / data structures implemented.  Once there is an acceptably efficient
solution presented, the final level of software engineering is to implement your solution via the gateway of coding, and from there 
debugging any problems / logical errors present.  While I don't believe the solution has to be the most efficient, it should be efficient
for large datasets.


